{"ast":null,"code":"/*\nCopyright (c) 2019 Daybrush\nname: order-map\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/order-map.git\nversion: 0.2.2\n*/\n\n/**\n *\n */\nvar OrderMap = /*#__PURE__*/function () {\n  /**\n   *\n   */\n  function OrderMap(separator) {\n    this.separator = separator;\n    this.orderMap = {};\n  }\n  /**\n   *\n   */\n\n\n  var __proto = OrderMap.prototype;\n\n  __proto.getFullName = function (names) {\n    return names.join(this.separator);\n  };\n  /**\n   *\n   */\n\n\n  __proto.get = function (names) {\n    return this.orderMap[this.getFullName(names)];\n  };\n  /**\n   *\n   */\n\n\n  __proto.gets = function (names, isFull) {\n    if (isFull === void 0) {\n      isFull = true;\n    }\n\n    var fullOrders = [];\n    var self = this;\n\n    function pushOrders(nextNames, stack) {\n      var orders = self.get(nextNames);\n\n      if (!orders) {\n        return;\n      }\n\n      orders.forEach(function (name) {\n        var nextStack = stack.concat([name]);\n        var nextOrders = pushOrders(nextNames.concat([name]), nextStack);\n\n        if (!nextOrders || !nextOrders.length) {\n          fullOrders.push(stack.concat([name]));\n        }\n      });\n      return orders;\n    }\n\n    pushOrders(names, isFull ? names : []);\n    return fullOrders;\n  };\n  /**\n   *\n   */\n\n\n  __proto.set = function (names, orders) {\n    var _this = this;\n\n    names.forEach(function (name, i) {\n      _this.addName(names.slice(0, i), name);\n    });\n    this.orderMap[this.getFullName(names)] = orders;\n    return orders;\n  };\n  /**\n   *\n   */\n\n\n  __proto.add = function (names) {\n    var length = names.length;\n\n    if (!length) {\n      return [];\n    }\n\n    return this.addName(names.slice(0, -1), names[length - 1]);\n  };\n  /**\n   *\n   */\n\n\n  __proto.addName = function (names, name) {\n    var orders = this.get(names) || this.set(names, []);\n\n    if (orders.indexOf(name) === -1) {\n      orders.push(name);\n    }\n\n    return orders;\n  };\n  /**\n   *\n   */\n\n\n  __proto.findIndex = function (names, orderName) {\n    var orders = this.orderMap[this.getFullName(names)];\n\n    if (!orders) {\n      return -1;\n    }\n\n    return orders.indexOf(orderName);\n  };\n  /**\n   *\n   */\n\n\n  __proto.remove = function (names) {\n    var fullName = this.getFullName(names);\n    var orderMap = this.orderMap;\n\n    for (var name in orderMap) {\n      if (name.indexOf(fullName) === 0) {\n        delete orderMap[name];\n      }\n    }\n\n    var length = names.length;\n\n    if (length) {\n      var prevNames = names.slice(0, -1);\n      var lastName = names[length - 1];\n      this.splice(prevNames, this.findIndex(prevNames, lastName), 1);\n    }\n\n    return this;\n  };\n  /**\n   *\n   */\n\n\n  __proto.filter = function (names, callback, isFull) {\n    if (isFull === void 0) {\n      isFull = true;\n    }\n\n    var result = this.gets(names, isFull).filter(callback);\n    var map = new OrderMap(this.separator);\n    var stack = isFull ? [] : names;\n    result.forEach(function (nextNames) {\n      map.add(stack.concat(nextNames));\n    });\n    return map;\n  };\n  /**\n   *\n   */\n\n\n  __proto.splice = function (names, index, deleteCount) {\n    var orders = [];\n\n    for (var _i = 3; _i < arguments.length; _i++) {\n      orders[_i - 3] = arguments[_i];\n    }\n\n    var currentOrders = this.get(names) || this.set(names, []);\n    currentOrders.splice.apply(currentOrders, [index, deleteCount].concat(orders));\n    return this;\n  };\n  /**\n   *\n   */\n\n\n  __proto.clear = function () {\n    this.orderMap = {};\n  };\n  /**\n   *\n   */\n\n\n  __proto.setObject = function (obj) {\n    var orderMap = this.orderMap;\n\n    for (var name in obj) {\n      orderMap[name] = obj[name].slice();\n    }\n  };\n  /**\n   *\n   */\n\n\n  __proto.getObject = function () {\n    var nextMap = {};\n    var orderMap = this.orderMap;\n\n    for (var name in orderMap) {\n      nextMap[name] = orderMap[name].slice();\n    }\n\n    return nextMap;\n  };\n  /**\n   *\n   */\n\n\n  __proto.clone = function () {\n    var map = new OrderMap(this.separator);\n    map.setObject(map.orderMap);\n    return map;\n  };\n\n  return OrderMap;\n}();\n\nexport default OrderMap;","map":{"version":3,"sources":["../src/OrderMap.ts"],"names":["names","isFull","fullOrders","self","orders","nextStack","stack","nextOrders","pushOrders","nextNames","_this","length","fullName","orderMap","name","prevNames","lastName","result","map","currentOrders","index","deleteCount","obj","nextMap"],"mappings":"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","sourcesContent":["import { IObject } from \"@daybrush/utils\";\n\n/**\n *\n */\nclass OrderMap<T = number | string> {\n    public orderMap: IObject<T[]> = {};\n\n    /**\n     *\n     */\n    constructor(private separator: string) { }\n\n    /**\n     *\n     */\n    public getFullName(names: T[]) {\n        return names.join(this.separator);\n    }\n\n    /**\n     *\n     */\n    public get(names: T[]): T[] | undefined {\n        return this.orderMap[this.getFullName(names)];\n    }\n\n    /**\n     *\n     */\n    public gets(names: T[], isFull = true): T[][] {\n        const fullOrders: T[][] = [];\n        const self = this;\n        function pushOrders(nextNames: T[], stack: T[]) {\n            const orders = self.get(nextNames);\n\n            if (!orders) {\n                return;\n            }\n            orders.forEach(name => {\n                const nextStack = [...stack, name];\n                const nextOrders = pushOrders([...nextNames, name], nextStack);\n\n                if (!nextOrders || !nextOrders.length) {\n                    fullOrders.push([...stack, name]);\n                }\n            });\n            return orders;\n        }\n\n        pushOrders(names, isFull ? names : []);\n\n        return fullOrders;\n    }\n\n    /**\n     *\n     */\n    public set(names: T[], orders: T[]): T[] {\n        names.forEach((name, i) => {\n            this.addName(names.slice(0, i), name);\n        });\n        this.orderMap[this.getFullName(names)] = orders;\n\n        return orders;\n    }\n\n    /**\n     *\n     */\n    public add(names: T[]): T[] {\n        const length = names.length;\n\n        if (!length) {\n            return [];\n        }\n        return this.addName(names.slice(0, -1), names[length - 1]);\n    }\n\n    /**\n     *\n     */\n    public addName(names: T[], name: T): T[] {\n        const orders = this.get(names) || this.set(names, []);\n\n        if (orders.indexOf(name) === -1) {\n            orders.push(name);\n        }\n        return orders;\n    }\n\n    /**\n     *\n     */\n    public findIndex(names: T[], orderName: T): number {\n        const orders = this.orderMap[this.getFullName(names)];\n\n        if (!orders) {\n            return -1;\n        }\n        return orders.indexOf(orderName);\n    }\n\n    /**\n     *\n     */\n    public remove(names: T[]): this {\n        const fullName = this.getFullName(names);\n        const orderMap = this.orderMap;\n\n        for (const name in orderMap) {\n            if (name.indexOf(fullName) === 0) {\n                delete orderMap[name];\n            }\n        }\n        const length = names.length;\n\n        if (length) {\n            const prevNames = names.slice(0, -1);\n            const lastName = names[length - 1];\n\n            this.splice(prevNames, this.findIndex(prevNames, lastName), 1);\n        }\n        return this;\n    }\n\n    /**\n     *\n     */\n    public filter(\n        names: T[],\n        callback: (value: T[], index: number, arr: T[][]) => boolean,\n        isFull = true,\n    ) {\n        const result = this.gets(names, isFull).filter(callback);\n        const map = new OrderMap<T>(this.separator);\n        const stack = isFull ? [] : names;\n\n        result.forEach(nextNames => {\n            map.add([...stack, ...nextNames]);\n        });\n\n        return map;\n    }\n\n    /**\n     *\n     */\n    public splice(names: T[], index: number, deleteCount: number, ...orders: T[]) {\n        const currentOrders = this.get(names) || this.set(names, []);\n\n        currentOrders.splice(index, deleteCount, ...orders);\n\n        return this;\n    }\n\n    /**\n     *\n     */\n    public clear() {\n        this.orderMap = {};\n    }\n\n    /**\n     *\n     */\n    public setObject(obj: IObject<T[]>) {\n        const orderMap = this.orderMap;\n\n        for (const name in obj) {\n            orderMap[name] = obj[name].slice();\n        }\n    }\n    /**\n     *\n     */\n    public getObject(): IObject<T[]> {\n        const nextMap = {};\n\n        const orderMap = this.orderMap;\n        for (const name in orderMap) {\n            nextMap[name] = orderMap[name].slice();\n        }\n        return nextMap;\n    }\n    /**\n     *\n     */\n    public clone() {\n        const map = new OrderMap<T>(this.separator);\n\n        map.setObject(map.orderMap);\n        return map;\n    }\n}\n\nexport default OrderMap;\n"]},"metadata":{},"sourceType":"module"}